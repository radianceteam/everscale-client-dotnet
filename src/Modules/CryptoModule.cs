using Newtonsoft.Json;
using System;
using System.Numerics;
using System.Threading.Tasks;
using TonSdk.Modules;

/*
* TON API version 1.0.0, crypto module.
* THIS FILE WAS GENERATED AUTOMATICALLY.
*/

namespace TonSdk.Modules
{
    public class ParamsOfFactorize
    {
        /// <summary>
        ///  Hexadecimal representation of u64 composite number.
        /// </summary>
        [JsonProperty("composite")]
        public string Composite { get; set; }
    }

    public class ResultOfFactorize
    {
        /// <summary>
        ///  Two factors of composite or empty if composite can't be factorized.
        /// </summary>
        [JsonProperty("factors")]
        public string[] Factors { get; set; }
    }

    public class ParamsOfModularPower
    {
        /// <summary>
        ///  `base` argument of calculation.
        /// </summary>
        [JsonProperty("base")]
        public string Base { get; set; }

        /// <summary>
        ///  `exponent` argument of calculation.
        /// </summary>
        [JsonProperty("exponent")]
        public string Exponent { get; set; }

        /// <summary>
        ///  `modulus` argument of calculation.
        /// </summary>
        [JsonProperty("modulus")]
        public string Modulus { get; set; }
    }

    public class ResultOfModularPower
    {
        /// <summary>
        ///  Result of modular exponentiation
        /// </summary>
        [JsonProperty("modular_power")]
        public string ModularPower { get; set; }
    }

    public class ParamsOfTonCrc16
    {
        /// <summary>
        ///  Input data for CRC calculation. Encoded with `base64`.
        /// </summary>
        [JsonProperty("data")]
        public string Data { get; set; }
    }

    public class ResultOfTonCrc16
    {
        /// <summary>
        ///  Calculated CRC for input data.
        /// </summary>
        [JsonProperty("crc")]
        public int Crc { get; set; }
    }

    public class ParamsOfGenerateRandomBytes
    {
        /// <summary>
        ///  Size of random byte array.
        /// </summary>
        [JsonProperty("length")]
        public int Length { get; set; }
    }

    public class ResultOfGenerateRandomBytes
    {
        /// <summary>
        ///  Generated bytes encoded in `base64`.
        /// </summary>
        [JsonProperty("bytes")]
        public string Bytes { get; set; }
    }

    public class ParamsOfConvertPublicKeyToTonSafeFormat
    {
        /// <summary>
        ///  Public key - 64 symbols hex string
        /// </summary>
        [JsonProperty("public_key")]
        public string PublicKey { get; set; }
    }

    public class ResultOfConvertPublicKeyToTonSafeFormat
    {
        /// <summary>
        ///  Public key represented in TON safe format. 
        /// </summary>
        [JsonProperty("ton_public_key")]
        public string TonPublicKey { get; set; }
    }

    public class KeyPair
    {
        /// <summary>
        ///  Public key - 64 symbols hex string
        /// </summary>
        [JsonProperty("public")]
        public string Public { get; set; }

        /// <summary>
        ///  Private key - u64 symbols hex string
        /// </summary>
        [JsonProperty("secret")]
        public string Secret { get; set; }
    }

    public class ParamsOfSign
    {
        /// <summary>
        ///  Data that must be signed encoded in `base64`.
        /// </summary>
        [JsonProperty("unsigned")]
        public string Unsigned { get; set; }

        /// <summary>
        ///  Sign keys.
        /// </summary>
        [JsonProperty("keys")]
        public KeyPair Keys { get; set; }
    }

    public class ResultOfSign
    {
        /// <summary>
        ///  Signed data combined with signature encoded in `base64`.
        /// </summary>
        [JsonProperty("signed")]
        public string Signed { get; set; }

        /// <summary>
        ///  Signature encoded in `hex`.
        /// </summary>
        [JsonProperty("signature")]
        public string Signature { get; set; }
    }

    public class ParamsOfVerifySignature
    {
        /// <summary>
        ///  Signed data that must be verified encoded in `base64`.
        /// </summary>
        [JsonProperty("signed")]
        public string Signed { get; set; }

        /// <summary>
        ///  Signer's public key - 64 symbols hex string
        /// </summary>
        [JsonProperty("public")]
        public string Public { get; set; }
    }

    public class ResultOfVerifySignature
    {
        /// <summary>
        ///  Unsigned data encoded in `base64`.
        /// </summary>
        [JsonProperty("unsigned")]
        public string Unsigned { get; set; }
    }

    public class ParamsOfHash
    {
        /// <summary>
        ///  Input data for hash calculation. Encoded with `base64`.
        /// </summary>
        [JsonProperty("data")]
        public string Data { get; set; }
    }

    public class ResultOfHash
    {
        /// <summary>
        ///  Hash of input `data`. Encoded with 'hex'.
        /// </summary>
        [JsonProperty("hash")]
        public string Hash { get; set; }
    }

    public class ParamsOfScrypt
    {
        /// <summary>
        ///  The password bytes to be hashed.
        ///  Must be encoded with `base64`.
        /// </summary>
        [JsonProperty("password")]
        public string Password { get; set; }

        /// <summary>
        ///  A salt bytes that modifies the hash to protect against Rainbow table attacks.
        ///  Must be encoded with `base64`.
        /// </summary>
        [JsonProperty("salt")]
        public string Salt { get; set; }

        /// <summary>
        ///  CPU/memory cost parameter
        /// </summary>
        [JsonProperty("log_n")]
        public int LogN { get; set; }

        /// <summary>
        ///  The block size parameter, which fine-tunes sequential memory read size and performance.
        /// </summary>
        [JsonProperty("r")]
        public int R { get; set; }

        /// <summary>
        ///  Parallelization parameter.
        /// </summary>
        [JsonProperty("p")]
        public int P { get; set; }

        /// <summary>
        ///  Intended output length in octets of the derived key.
        /// </summary>
        [JsonProperty("dk_len")]
        public int DkLen { get; set; }
    }

    public class ResultOfScrypt
    {
        /// <summary>
        ///  Derived key. Encoded with `hex`.
        /// </summary>
        [JsonProperty("key")]
        public string Key { get; set; }
    }

    public class ParamsOfNaclSignKeyPairFromSecret
    {
        /// <summary>
        ///  Secret key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("secret")]
        public string Secret { get; set; }
    }

    public class ParamsOfNaclSign
    {
        /// <summary>
        ///  Data that must be signed encoded in `base64`.
        /// </summary>
        [JsonProperty("unsigned")]
        public string Unsigned { get; set; }

        /// <summary>
        ///  Signer's secret key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("secret")]
        public string Secret { get; set; }
    }

    public class ResultOfNaclSign
    {
        /// <summary>
        ///  Signed data, encoded in `base64`.
        /// </summary>
        [JsonProperty("signed")]
        public string Signed { get; set; }
    }

    public class ParamsOfNaclSignOpen
    {
        /// <summary>
        ///  Signed data that must be unsigned. Encoded with `base64`.
        /// </summary>
        [JsonProperty("signed")]
        public string Signed { get; set; }

        /// <summary>
        ///  Signer's public key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("public")]
        public string Public { get; set; }
    }

    public class ResultOfNaclSignOpen
    {
        /// <summary>
        ///  Unsigned data, encoded in `base64`.
        /// </summary>
        [JsonProperty("unsigned")]
        public string Unsigned { get; set; }
    }

    public class ResultOfNaclSignDetached
    {
        /// <summary>
        ///  Signature encoded in `hex`.
        /// </summary>
        [JsonProperty("signature")]
        public string Signature { get; set; }
    }

    public class ParamsOfNaclBoxKeyPairFromSecret
    {
        /// <summary>
        ///  Secret key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("secret")]
        public string Secret { get; set; }
    }

    public class ParamsOfNaclBox
    {
        /// <summary>
        ///  Data that must be encrypted encoded in `base64`.
        /// </summary>
        [JsonProperty("decrypted")]
        public string Decrypted { get; set; }

        /// <summary>
        ///  Nonce, encoded in `hex`
        /// </summary>
        [JsonProperty("nonce")]
        public string Nonce { get; set; }

        /// <summary>
        ///  Receiver's public key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("their_public")]
        public string TheirPublic { get; set; }

        /// <summary>
        ///  Sender's private key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("secret")]
        public string Secret { get; set; }
    }

    public class ResultOfNaclBox
    {
        /// <summary>
        ///  Encrypted data encoded in `base64`.
        /// </summary>
        [JsonProperty("encrypted")]
        public string Encrypted { get; set; }
    }

    public class ParamsOfNaclBoxOpen
    {
        /// <summary>
        ///  Data that must be decrypted. Encoded with `base64`.
        /// </summary>
        [JsonProperty("encrypted")]
        public string Encrypted { get; set; }

        [JsonProperty("nonce")]
        public string Nonce { get; set; }

        /// <summary>
        ///  Sender's public key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("their_public")]
        public string TheirPublic { get; set; }

        /// <summary>
        ///  Receiver's private key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("secret")]
        public string Secret { get; set; }
    }

    public class ResultOfNaclBoxOpen
    {
        /// <summary>
        ///  Decrypted data encoded in `base64`.
        /// </summary>
        [JsonProperty("decrypted")]
        public string Decrypted { get; set; }
    }

    public class ParamsOfNaclSecretBox
    {
        /// <summary>
        ///  Data that must be encrypted. Encoded with `base64`.
        /// </summary>
        [JsonProperty("decrypted")]
        public string Decrypted { get; set; }

        /// <summary>
        ///  Nonce in `hex`
        /// </summary>
        [JsonProperty("nonce")]
        public string Nonce { get; set; }

        /// <summary>
        ///  Secret key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("key")]
        public string Key { get; set; }
    }

    public class ParamsOfNaclSecretBoxOpen
    {
        /// <summary>
        ///  Data that must be decrypted. Encoded with `base64`.
        /// </summary>
        [JsonProperty("encrypted")]
        public string Encrypted { get; set; }

        /// <summary>
        ///  Nonce in `hex`
        /// </summary>
        [JsonProperty("nonce")]
        public string Nonce { get; set; }

        /// <summary>
        ///  Public key - unprefixed 0-padded to 64 symbols hex string 
        /// </summary>
        [JsonProperty("key")]
        public string Key { get; set; }
    }

    public class ParamsOfMnemonicWords
    {
        /// <summary>
        ///  Dictionary identifier
        /// </summary>
        [JsonProperty("dictionary")]
        public int? Dictionary { get; set; }
    }

    public class ResultOfMnemonicWords
    {
        /// <summary>
        ///  The list of mnemonic words
        /// </summary>
        [JsonProperty("words")]
        public string Words { get; set; }
    }

    public class ParamsOfMnemonicFromRandom
    {
        /// <summary>
        ///  Dictionary identifier
        /// </summary>
        [JsonProperty("dictionary")]
        public int? Dictionary { get; set; }

        /// <summary>
        ///  Mnemonic word count
        /// </summary>
        [JsonProperty("word_count")]
        public int? WordCount { get; set; }
    }

    public class ResultOfMnemonicFromRandom
    {
        /// <summary>
        ///  String of mnemonic words
        /// </summary>
        [JsonProperty("phrase")]
        public string Phrase { get; set; }
    }

    public class ParamsOfMnemonicFromEntropy
    {
        /// <summary>
        ///  Entropy bytes. Hex encoded.
        /// </summary>
        [JsonProperty("entropy")]
        public string Entropy { get; set; }

        /// <summary>
        ///  Dictionary identifier
        /// </summary>
        [JsonProperty("dictionary")]
        public int? Dictionary { get; set; }

        /// <summary>
        ///  Mnemonic word count
        /// </summary>
        [JsonProperty("word_count")]
        public int? WordCount { get; set; }
    }

    public class ResultOfMnemonicFromEntropy
    {
        /// <summary>
        ///  Phrase
        /// </summary>
        [JsonProperty("phrase")]
        public string Phrase { get; set; }
    }

    public class ParamsOfMnemonicVerify
    {
        /// <summary>
        ///  Phrase
        /// </summary>
        [JsonProperty("phrase")]
        public string Phrase { get; set; }

        /// <summary>
        ///  Dictionary identifier
        /// </summary>
        [JsonProperty("dictionary")]
        public int? Dictionary { get; set; }

        /// <summary>
        ///  Word count
        /// </summary>
        [JsonProperty("word_count")]
        public int? WordCount { get; set; }
    }

    public class ResultOfMnemonicVerify
    {
        /// <summary>
        ///  Flag indicating the mnemonic is valid or not
        /// </summary>
        [JsonProperty("valid")]
        public bool Valid { get; set; }
    }

    public class ParamsOfMnemonicDeriveSignKeys
    {
        /// <summary>
        ///  Phrase
        /// </summary>
        [JsonProperty("phrase")]
        public string Phrase { get; set; }

        /// <summary>
        ///  Derivation path, for instance "m/44'/396'/0'/0/0"
        /// </summary>
        [JsonProperty("path")]
        public string Path { get; set; }

        /// <summary>
        ///  Dictionary identifier
        /// </summary>
        [JsonProperty("dictionary")]
        public int? Dictionary { get; set; }

        /// <summary>
        ///  Word count
        /// </summary>
        [JsonProperty("word_count")]
        public int? WordCount { get; set; }
    }

    public class ParamsOfHDKeyXPrvFromMnemonic
    {
        /// <summary>
        ///  String with seed phrase
        /// </summary>
        [JsonProperty("phrase")]
        public string Phrase { get; set; }
    }

    public class ResultOfHDKeyXPrvFromMnemonic
    {
        /// <summary>
        ///  Serialized extended master private key
        /// </summary>
        [JsonProperty("xprv")]
        public string Xprv { get; set; }
    }

    public class ParamsOfHDKeyDeriveFromXPrv
    {
        /// <summary>
        ///  Serialized extended private key
        /// </summary>
        [JsonProperty("xprv")]
        public string Xprv { get; set; }

        /// <summary>
        ///  Child index (see BIP-0032)
        /// </summary>
        [JsonProperty("child_index")]
        public int ChildIndex { get; set; }

        /// <summary>
        ///  Indicates the derivation of hardened/not-hardened key (see BIP-0032)
        /// </summary>
        [JsonProperty("hardened")]
        public bool Hardened { get; set; }
    }

    public class ResultOfHDKeyDeriveFromXPrv
    {
        /// <summary>
        ///  Serialized extended private key
        /// </summary>
        [JsonProperty("xprv")]
        public string Xprv { get; set; }
    }

    public class ParamsOfHDKeyDeriveFromXPrvPath
    {
        /// <summary>
        ///  Serialized extended private key
        /// </summary>
        [JsonProperty("xprv")]
        public string Xprv { get; set; }

        /// <summary>
        ///  Derivation path, for instance "m/44'/396'/0'/0/0"
        /// </summary>
        [JsonProperty("path")]
        public string Path { get; set; }
    }

    public class ResultOfHDKeyDeriveFromXPrvPath
    {
        /// <summary>
        ///  Derived serialized extended private key
        /// </summary>
        [JsonProperty("xprv")]
        public string Xprv { get; set; }
    }

    public class ParamsOfHDKeySecretFromXPrv
    {
        /// <summary>
        ///  Serialized extended private key
        /// </summary>
        [JsonProperty("xprv")]
        public string Xprv { get; set; }
    }

    public class ResultOfHDKeySecretFromXPrv
    {
        /// <summary>
        ///  Private key - 64 symbols hex string
        /// </summary>
        [JsonProperty("secret")]
        public string Secret { get; set; }
    }

    public class ParamsOfHDKeyPublicFromXPrv
    {
        /// <summary>
        ///  Serialized extended private key
        /// </summary>
        [JsonProperty("xprv")]
        public string Xprv { get; set; }
    }

    public class ResultOfHDKeyPublicFromXPrv
    {
        /// <summary>
        ///  Public key - 64 symbols hex string
        /// </summary>
        [JsonProperty("public")]
        public string Public { get; set; }
    }

    /// <summary>
    ///  Crypto functions.
    /// </summary>
    public interface ICryptoModule
    {
        /// <summary>
        ///  Performs prime factorization â€“ decomposition of a composite number
        ///  into a product of smaller prime integers (factors).
        ///  See [https://en.wikipedia.org/wiki/Integer_factorization]
        /// </summary>
        Task<ResultOfFactorize> FactorizeAsync(ParamsOfFactorize @params);

        /// <summary>
        ///  Performs modular exponentiation for big integers (`base`^`exponent` mod `modulus`).
        ///  See [https://en.wikipedia.org/wiki/Modular_exponentiation]
        /// </summary>
        Task<ResultOfModularPower> ModularPowerAsync(ParamsOfModularPower @params);

        /// <summary>
        ///  Calculates CRC16 using TON algorithm.
        /// </summary>
        Task<ResultOfTonCrc16> TonCrc16Async(ParamsOfTonCrc16 @params);

        /// <summary>
        ///  Generates random byte array of the specified length and returns it in `base64` format
        /// </summary>
        Task<ResultOfGenerateRandomBytes> GenerateRandomBytesAsync(ParamsOfGenerateRandomBytes @params);

        /// <summary>
        ///  Converts public key to ton safe_format
        /// </summary>
        Task<ResultOfConvertPublicKeyToTonSafeFormat> ConvertPublicKeyToTonSafeFormatAsync(ParamsOfConvertPublicKeyToTonSafeFormat @params);

        /// <summary>
        ///  Generates random ed25519 key pair.
        /// </summary>
        Task<KeyPair> GenerateRandomSignKeysAsync();

        /// <summary>
        ///  Signs a data using the provided keys.
        /// </summary>
        Task<ResultOfSign> SignAsync(ParamsOfSign @params);

        /// <summary>
        ///  Verifies signed data using the provided public key.
        ///  Raises error if verification is failed.
        /// </summary>
        Task<ResultOfVerifySignature> VerifySignatureAsync(ParamsOfVerifySignature @params);

        /// <summary>
        ///  Calculates SHA256 hash of the specified data.
        /// </summary>
        Task<ResultOfHash> Sha256Async(ParamsOfHash @params);

        /// <summary>
        ///  Calculates SHA512 hash of the specified data.
        /// </summary>
        Task<ResultOfHash> Sha512Async(ParamsOfHash @params);

        /// <summary>
        ///  Derives key from `password` and `key` using `scrypt` algorithm.
        ///  See [https://en.wikipedia.org/wiki/Scrypt].
        /// 
        ///  # Arguments
        ///  - `log_n` - The log2 of the Scrypt parameter `N`
        ///  - `r` - The Scrypt parameter `r`
        ///  - `p` - The Scrypt parameter `p`
        ///  # Conditions
        ///  - `log_n` must be less than `64`
        ///  - `r` must be greater than `0` and less than or equal to `4294967295`
        ///  - `p` must be greater than `0` and less than `4294967295`
        ///  # Recommended values sufficient for most use-cases
        ///  - `log_n = 15` (`n = 32768`)
        ///  - `r = 8`
        ///  - `p = 1`
        /// </summary>
        Task<ResultOfScrypt> ScryptAsync(ParamsOfScrypt @params);

        /// <summary>
        ///  Generates a key pair for signing from the secret key
        /// </summary>
        Task<KeyPair> NaclSignKeypairFromSecretKeyAsync(ParamsOfNaclSignKeyPairFromSecret @params);

        /// <summary>
        ///  Signs data using the signer's secret key.
        /// </summary>
        Task<ResultOfNaclSign> NaclSignAsync(ParamsOfNaclSign @params);

        Task<ResultOfNaclSignOpen> NaclSignOpenAsync(ParamsOfNaclSignOpen @params);

        Task<ResultOfNaclSignDetached> NaclSignDetachedAsync(ParamsOfNaclSign @params);

        Task<KeyPair> NaclBoxKeypairAsync();

        /// <summary>
        ///  Generates key pair from a secret key
        /// </summary>
        Task<KeyPair> NaclBoxKeypairFromSecretKeyAsync(ParamsOfNaclBoxKeyPairFromSecret @params);

        /// <summary>
        ///  Public key authenticated encryption
        /// 
        ///  Encrypt and authenticate a message using the senders secret key, the recievers public
        ///  key, and a nonce. 
        /// </summary>
        Task<ResultOfNaclBox> NaclBoxAsync(ParamsOfNaclBox @params);

        /// <summary>
        ///  Decrypt and verify the cipher text using the recievers secret key, the senders public
        ///  key, and the nonce.
        /// </summary>
        Task<ResultOfNaclBoxOpen> NaclBoxOpenAsync(ParamsOfNaclBoxOpen @params);

        /// <summary>
        ///  Encrypt and authenticate message using nonce and secret key.
        /// </summary>
        Task<ResultOfNaclBox> NaclSecretBoxAsync(ParamsOfNaclSecretBox @params);

        /// <summary>
        ///  Decrypts and verifies cipher text using `nonce` and secret `key`.
        /// </summary>
        Task<ResultOfNaclBoxOpen> NaclSecretBoxOpenAsync(ParamsOfNaclSecretBoxOpen @params);

        /// <summary>
        ///  Prints the list of words from the specified dictionary
        /// </summary>
        Task<ResultOfMnemonicWords> MnemonicWordsAsync(ParamsOfMnemonicWords @params);

        /// <summary>
        ///  Generates a random mnemonic from the specified dictionary and word count
        /// </summary>
        Task<ResultOfMnemonicFromRandom> MnemonicFromRandomAsync(ParamsOfMnemonicFromRandom @params);

        /// <summary>
        ///  Generates mnemonic from pre-generated entropy
        /// </summary>
        Task<ResultOfMnemonicFromEntropy> MnemonicFromEntropyAsync(ParamsOfMnemonicFromEntropy @params);

        /// <summary>
        ///  The phrase supplied will be checked for word length and validated according to the checksum
        ///  specified in BIP0039.
        /// </summary>
        Task<ResultOfMnemonicVerify> MnemonicVerifyAsync(ParamsOfMnemonicVerify @params);

        /// <summary>
        ///  Validates the seed phrase, generates master key and then derives
        ///  the key pair from the master key and the specified path
        /// </summary>
        Task<KeyPair> MnemonicDeriveSignKeysAsync(ParamsOfMnemonicDeriveSignKeys @params);

        /// <summary>
        ///  Generates an extended master private key that will be the root for all the derived keys
        /// </summary>
        Task<ResultOfHDKeyXPrvFromMnemonic> HdkeyXprvFromMnemonicAsync(ParamsOfHDKeyXPrvFromMnemonic @params);

        /// <summary>
        ///  Returns extended private key derived from the specified extended private key and child index
        /// </summary>
        Task<ResultOfHDKeyDeriveFromXPrv> HdkeyDeriveFromXprvAsync(ParamsOfHDKeyDeriveFromXPrv @params);

        /// <summary>
        ///  Derives the exented private key from the specified key and path
        /// </summary>
        Task<ResultOfHDKeyDeriveFromXPrvPath> HdkeyDeriveFromXprvPathAsync(ParamsOfHDKeyDeriveFromXPrvPath @params);

        /// <summary>
        ///  Extracts the private key from the serialized extended private key
        /// </summary>
        Task<ResultOfHDKeySecretFromXPrv> HdkeySecretFromXprvAsync(ParamsOfHDKeySecretFromXPrv @params);

        /// <summary>
        ///  Extracts the public key from the serialized extended private key
        /// </summary>
        Task<ResultOfHDKeyPublicFromXPrv> HdkeyPublicFromXprvAsync(ParamsOfHDKeyPublicFromXPrv @params);
    }

    internal class CryptoModule : ICryptoModule
    {
        private readonly TonClient _client;

        internal CryptoModule(TonClient client)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
        }

        public async Task<ResultOfFactorize> FactorizeAsync(ParamsOfFactorize @params)
        {
            return await _client.CallFunctionAsync<ResultOfFactorize>("crypto.factorize", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfModularPower> ModularPowerAsync(ParamsOfModularPower @params)
        {
            return await _client.CallFunctionAsync<ResultOfModularPower>("crypto.modular_power", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfTonCrc16> TonCrc16Async(ParamsOfTonCrc16 @params)
        {
            return await _client.CallFunctionAsync<ResultOfTonCrc16>("crypto.ton_crc16", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfGenerateRandomBytes> GenerateRandomBytesAsync(ParamsOfGenerateRandomBytes @params)
        {
            return await _client.CallFunctionAsync<ResultOfGenerateRandomBytes>("crypto.generate_random_bytes", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfConvertPublicKeyToTonSafeFormat> ConvertPublicKeyToTonSafeFormatAsync(ParamsOfConvertPublicKeyToTonSafeFormat @params)
        {
            return await _client.CallFunctionAsync<ResultOfConvertPublicKeyToTonSafeFormat>("crypto.convert_public_key_to_ton_safe_format", @params).ConfigureAwait(false);
        }

        public async Task<KeyPair> GenerateRandomSignKeysAsync()
        {
            return await _client.CallFunctionAsync<KeyPair>("crypto.generate_random_sign_keys").ConfigureAwait(false);
        }

        public async Task<ResultOfSign> SignAsync(ParamsOfSign @params)
        {
            return await _client.CallFunctionAsync<ResultOfSign>("crypto.sign", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfVerifySignature> VerifySignatureAsync(ParamsOfVerifySignature @params)
        {
            return await _client.CallFunctionAsync<ResultOfVerifySignature>("crypto.verify_signature", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfHash> Sha256Async(ParamsOfHash @params)
        {
            return await _client.CallFunctionAsync<ResultOfHash>("crypto.sha256", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfHash> Sha512Async(ParamsOfHash @params)
        {
            return await _client.CallFunctionAsync<ResultOfHash>("crypto.sha512", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfScrypt> ScryptAsync(ParamsOfScrypt @params)
        {
            return await _client.CallFunctionAsync<ResultOfScrypt>("crypto.scrypt", @params).ConfigureAwait(false);
        }

        public async Task<KeyPair> NaclSignKeypairFromSecretKeyAsync(ParamsOfNaclSignKeyPairFromSecret @params)
        {
            return await _client.CallFunctionAsync<KeyPair>("crypto.nacl_sign_keypair_from_secret_key", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfNaclSign> NaclSignAsync(ParamsOfNaclSign @params)
        {
            return await _client.CallFunctionAsync<ResultOfNaclSign>("crypto.nacl_sign", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfNaclSignOpen> NaclSignOpenAsync(ParamsOfNaclSignOpen @params)
        {
            return await _client.CallFunctionAsync<ResultOfNaclSignOpen>("crypto.nacl_sign_open", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfNaclSignDetached> NaclSignDetachedAsync(ParamsOfNaclSign @params)
        {
            return await _client.CallFunctionAsync<ResultOfNaclSignDetached>("crypto.nacl_sign_detached", @params).ConfigureAwait(false);
        }

        public async Task<KeyPair> NaclBoxKeypairAsync()
        {
            return await _client.CallFunctionAsync<KeyPair>("crypto.nacl_box_keypair").ConfigureAwait(false);
        }

        public async Task<KeyPair> NaclBoxKeypairFromSecretKeyAsync(ParamsOfNaclBoxKeyPairFromSecret @params)
        {
            return await _client.CallFunctionAsync<KeyPair>("crypto.nacl_box_keypair_from_secret_key", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfNaclBox> NaclBoxAsync(ParamsOfNaclBox @params)
        {
            return await _client.CallFunctionAsync<ResultOfNaclBox>("crypto.nacl_box", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfNaclBoxOpen> NaclBoxOpenAsync(ParamsOfNaclBoxOpen @params)
        {
            return await _client.CallFunctionAsync<ResultOfNaclBoxOpen>("crypto.nacl_box_open", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfNaclBox> NaclSecretBoxAsync(ParamsOfNaclSecretBox @params)
        {
            return await _client.CallFunctionAsync<ResultOfNaclBox>("crypto.nacl_secret_box", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfNaclBoxOpen> NaclSecretBoxOpenAsync(ParamsOfNaclSecretBoxOpen @params)
        {
            return await _client.CallFunctionAsync<ResultOfNaclBoxOpen>("crypto.nacl_secret_box_open", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfMnemonicWords> MnemonicWordsAsync(ParamsOfMnemonicWords @params)
        {
            return await _client.CallFunctionAsync<ResultOfMnemonicWords>("crypto.mnemonic_words", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfMnemonicFromRandom> MnemonicFromRandomAsync(ParamsOfMnemonicFromRandom @params)
        {
            return await _client.CallFunctionAsync<ResultOfMnemonicFromRandom>("crypto.mnemonic_from_random", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfMnemonicFromEntropy> MnemonicFromEntropyAsync(ParamsOfMnemonicFromEntropy @params)
        {
            return await _client.CallFunctionAsync<ResultOfMnemonicFromEntropy>("crypto.mnemonic_from_entropy", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfMnemonicVerify> MnemonicVerifyAsync(ParamsOfMnemonicVerify @params)
        {
            return await _client.CallFunctionAsync<ResultOfMnemonicVerify>("crypto.mnemonic_verify", @params).ConfigureAwait(false);
        }

        public async Task<KeyPair> MnemonicDeriveSignKeysAsync(ParamsOfMnemonicDeriveSignKeys @params)
        {
            return await _client.CallFunctionAsync<KeyPair>("crypto.mnemonic_derive_sign_keys", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfHDKeyXPrvFromMnemonic> HdkeyXprvFromMnemonicAsync(ParamsOfHDKeyXPrvFromMnemonic @params)
        {
            return await _client.CallFunctionAsync<ResultOfHDKeyXPrvFromMnemonic>("crypto.hdkey_xprv_from_mnemonic", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfHDKeyDeriveFromXPrv> HdkeyDeriveFromXprvAsync(ParamsOfHDKeyDeriveFromXPrv @params)
        {
            return await _client.CallFunctionAsync<ResultOfHDKeyDeriveFromXPrv>("crypto.hdkey_derive_from_xprv", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfHDKeyDeriveFromXPrvPath> HdkeyDeriveFromXprvPathAsync(ParamsOfHDKeyDeriveFromXPrvPath @params)
        {
            return await _client.CallFunctionAsync<ResultOfHDKeyDeriveFromXPrvPath>("crypto.hdkey_derive_from_xprv_path", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfHDKeySecretFromXPrv> HdkeySecretFromXprvAsync(ParamsOfHDKeySecretFromXPrv @params)
        {
            return await _client.CallFunctionAsync<ResultOfHDKeySecretFromXPrv>("crypto.hdkey_secret_from_xprv", @params).ConfigureAwait(false);
        }

        public async Task<ResultOfHDKeyPublicFromXPrv> HdkeyPublicFromXprvAsync(ParamsOfHDKeyPublicFromXPrv @params)
        {
            return await _client.CallFunctionAsync<ResultOfHDKeyPublicFromXPrv>("crypto.hdkey_public_from_xprv", @params).ConfigureAwait(false);
        }
    }
}

namespace TonSdk
{
    public partial interface ITonClient
    {
        ICryptoModule Crypto { get; }
    }

    public partial class TonClient
    {
        private CryptoModule _cryptoModule;

        public ICryptoModule Crypto
        {
            get
            {
                return _cryptoModule ?? (_cryptoModule = new CryptoModule(this));
            }
        }
    }
}

